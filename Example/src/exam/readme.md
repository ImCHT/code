1. 理解题意。如果可以上网，可以搜下，要录屏，关手机时更可能有原题。
2. 举例分析
3. 理清思路
4. 动手编程。注意特殊情况，方法参数不合法或为空，索引超出范围，链表节点为空等等。
##算法
###双指针
1. 一个先走n步，再一起同步走
2. 两个指针步长不同，一个一次走1步，另一个一次走2步
3. 一个指针指左边，一个指针指右边
4. 指向两个不同对象(数组)
###动态规划
和递归的区别，动态规划保存了子问题的解，避免重复计算（用opt数组保存）
1. 考虑能否变成相互包含的小问题。可根据小问题的解求大问题的解
2. 确定opt一维还是两维，各维的含义。画图
3. 根据不同情况，写出递推式。取/不取，或者题目规定的各种情况
4. 确定出口条件
5. 用递归或者循环生成opt数组进行求解
###广度优先搜索
概念：广度优先搜索一层一层地进行遍历，每层遍历都以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。
需要注意的是，遍历过的节点不能再次被遍历。
<br>适用问题：`最短路径等最优解`问题
<br>在程序实现 BFS 时需要考虑以下问题：
1. 队列：用来存储每一轮遍历得到的节点；
2. 标记：对于遍历过的节点，应该将它标记，防止重复遍历。数组，存放节点的所有可能值。
3. 确定节点的含义是什么：应该是与最终目标直接相关的
4. 每次遍历需要对每个节点需要做的操作是什么：比如二叉树是遍历节点的左右节点；矩阵查找上下左右
###深度优先搜索
概念：得到一个新节点后立即对新节点进行遍历；遍历完之后返回到之前没有遍历的节点
<br>适用问题：从一个节点出发，使用DFS对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，
常用来求解`可达性`问题
<br>在程序实现DFS时需要考虑的问题：
1. 栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。
2. 标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。
3. `一般先需要找到特点的节点，然后对特定节点进行DFS。要确定特地节点的特点是什么；深度优先搜索时需要做什么操作。`
4. 下一层DFS的条件
5. 出口条件。DFS方法需要的参数
###回溯
概念：Backtracking(回溯)属于DFS。
+ 普通 DFS 主要用在可达性问题，这种问题只需要执行到特点的位置然后返回即可。
+ 而Backtracking主要用于`求解排列组合问题`，例如有 { 'a','b','c' } 三个字符，求解所有由这三个
字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。
<br>因为Backtracking不是立即就返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：
+ 在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；
+ 但是在`递归返回时，需要将元素标记为未访问`，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。
##注意点
1. 没思路的时候，举例去分析，说不定就有思路了。分个情况
2. 输入数据的范围，看int能不能存的下
###失误
1. 数组、字符串最前面位置的索引为0
2. 位置i关于中间位置对称后一半的位置为length-i-1，而不是length-i
3. 0也是整数
4. int(32位)：范围-2147483648~2147483647。大概为±2*10^9
5. 字符转化为小写Character.toLowerCase
6. 得到去除最后一个字符的字符串需要用：string.subString(`0,string.length-1`);
